# Use an existing monad
During the last few iterations, a concept emerged from our code: `ConversionResult`.
It has evolved since it first appeared and now looks like a `monad`. 
Let's try to use the advantages of existing ones instead of having our own one.

In `C#`, we can use a library called [language-ext](https://github.com/louthy/language-ext) that extends `C#` with a lot of functional programming oriented classes and features.

As a reminder, this is what our `ConversionResult` looks like at the moment:
```csharp
public class ConversionResult<T>
{
    public ConversionResult(Money money)
    {
        this.Money = money;
    }

    public ConversionResult(T failure)
    {
        this.Failure = failure;
    }

    public Money? Money { get; }

    public T? Failure { get; }

    public bool IsFailure() => this.Failure is { };

    public bool IsSuccess() => this.Money is { };

    public static ConversionResult<T> FromFailure(T failure) => new ConversionResult<T>(failure);

    public static ConversionResult<T> FromMoney(Money money) => new ConversionResult<T>(money);
}
```

## Which monad?
In `language-ext`, some useful monad types have already been defined.

![Available monads](img/LanguageExtMonads.png)

> Given the ConversionResult behavior, we are looking for a monad that can hold one of the 2 possible values: either a `success` or a `failure`.

- [`Option`](https://louthy.github.io/language-ext/LanguageExt.Core/Monads/Alternative%20Value%20Monads/Option/Option/index.html) is a monadic container type which represents an optional value
  - Instances of Option are either an instance of `Some` or `None`
  - It cannot hold 2 different types of value
- [`Try`](https://louthy.github.io/language-ext/LanguageExt.Core/Monads/Alternative%20Value%20Monads/Try/Try/index.html) is a monadic container type which represents a computation that may either result in an exception, or return a successfully computed value 
  - Instances of Try, are either an instance of `Success` or `Failure`
  - `It looks like a good candidate`
- [`Either`](https://louthy.github.io/language-ext/LanguageExt.Core/Monads/Alternative%20Value%20Monads/Either/Either/index.html) represents a value of two possible types
  - An `Either` is either a Left or a Right
  - `Another good candidate`
- [`Validation`](https://louthy.github.io/language-ext/LanguageExt.Core/Monads/Alternative%20Value%20Monads/Validation/index.html) is an applicative functor and facilitates accumulating errors
  - Not exactly what we're looking for at the moment 

The `Try` monad could be a good idea with notions of success/failure but it seems it won't fit.
We recently removed exceptions and our current monad return either a Money or a String. 

Finally, we decide to use the `Either` monad.

## Either monad
We start by adding the `LanguageExt.Core` package to our projects:

```xml
<ItemGroup>
  <PackageReference Include="LanguageExt.Core" Version="4.2.9" />
</ItemGroup>
```

As we rely a lot on `FluentAssertions`, we can also include `FluentAssertions.LanguageExt` to simplify the use of monads in our tests.
It means we won't have to extract values from monads in order to assert them.

```xml
<ItemGroup>
  <PackageReference Include="FluentAssertions.LanguageExt" Version="0.2.1" />
</ItemGroup>
```

### Portfolio
:red_circle: You know the drill by now, new `TDD` cycle. As usual, we start with a red test on the `Portfolio`.

We are going to use a technique we used before, the `Strangler` pattern, to change a method signature without breaking our production code or our tests.

- We rename the current `Evaluate` method into `EvaluateWithConversionResult`
- We adapt a test to use the future `Evaluate` method with a signature like this: `Bank` -> `Currency` -> `Either<String, Money>`
  - By convention, `Left` is the failure case when using `Either`
- We use `FluentAssertions.LanguageExt`

```csharp
[Fact(DisplayName = "5 USD + 10 EUR = 17 USD")]
public void Add_ShouldAddMoneyInDollarAndEuro() =>
    PortfolioWith(5d.Dollars(), 10d.Euros())
        .Evaluate(this.bank, Currency.USD)
        .Should()
        .Be(17d.Dollars());
```

It's not eye-popping but `FluentAssertions.LanguageExt` is really helpful here. 
`Evaluate` returns an `Either<string, Money>` and, thanks to the library, `.Should().Be(...)` will assert on the left or right part of the monad depending on the object we pass. 
`string` will evaluate the left part while `Money` will evaluate the right part.


Then, we generate the new method from the test:

```csharp
public Either<string, Money> Evaluate(Bank bank, Currency usd)
{
    throw new NotImplementedException();
}

public ConversionResult<string> EvaluateWithConversionResult(Bank bank, Currency currency)
{
    var results = this.GetConvertedMoneys(bank, currency);
    return ContainsFailure(results)
        ? ConversionResult<string>.FromFailure(this.ToFailure(results))
        : ConversionResult<string>.FromMoney(this.ToSuccess(results, currency));
}
```

:green_circle: We implement the method using the old one by using `Left()` and `Right()` methods from `Either`.

```csharp
public Either<string, Money> Evaluate(Bank bank, Currency currency)
{
    var result = this.EvaluateWithConversionResult(bank, currency);
    return result.IsFailure()
        ? Either<string, Money>.Left(result.Failure!)
        : Either<string, Money>.Right(result.Money!);
}
```

:large_blue_circle: Refactor time!
We can now put the logic from `EvaluateWithConversionResult` into `Evaluate` and verify if our tests still pass.

```csharp
public Either<string, Money> Evaluate(Bank bank, Currency currency)
{
    var results = this.GetConvertedMoneys(bank, currency);
    return ContainsFailure(results)
        ? Either<string, Money>.Left(this.ToFailure(results))
        : Either<string, Money>.Right(this.ToSuccess(results, currency));
}
```

`Evaluate` is now works independent from `EvaluateWithConversionResult`.

:large_blue_circle: We can now decommission `EvaluateWithConversionResult` by calling `Evaluate` from our tests.

```csharp
[Fact(DisplayName = "1 USD + 1100 KRW = 2200 KRW")]
public void Add_ShouldAddMoneyInDollarAndKoreanWons() =>
    PortfolioWith(1d.Dollars(), 1100d.KoreanWons())
        .Evaluate(this.bank, Currency.KRW)
        .Should()
        .Be(2200d.KoreanWons());

[Fact(DisplayName = "5 USD + 10 EUR + 4 EUR = 21.8 USD")]
public void Add_ShouldAddMoneyInDollarsAndMultipleAmountInEuros() =>
    PortfolioWith(5d.Dollars(), 10d.Euros(), 4d.Euros())
        .Evaluate(bank, Currency.USD)
        .Should()
        .Be(21.8.Dollars());

[Fact(DisplayName = "Throws a MissingExchangeRatesException in case of missing exchange rates")]
public void Add_ShouldThrowAMissingExchangeRatesException()
{
    PortfolioWith(1d.Euros(), 1d.Dollars(), 1d.KoreanWons())
        .Evaluate(this.bank, Currency.EUR)
        .Should()
        .Be("Missing exchange rate(s): [USD->EUR],[KRW->EUR]");
}

[Fact(DisplayName = "5 USD + 10 USD = 15 USD")]
public void Add_ShouldAddMoneyInTheSameCurrency() =>
    PortfolioWith(5d.Dollars(), 10d.Dollars())
        .Evaluate(bank, Currency.USD)
        .Should()
        .Be(15d.Dollars());
```

Finally, `EvaluateWithConversionResult` is now considered `dead code` and we can safely remove it safely.

Another refactoring done right with `TDD`!

### Bank
Let's do the same at the `Bank` level

:red_circle: We adapt an existing test.

```java
@Test
@DisplayName("10 EUR -> USD = 12 USD")
void shouldConvertEuroToUsd() {
    VavrAssertions
            .assertThat(bank.convert(euros(10), USD))
            .containsOnRight(dollars(12));
}
```

Then we generate our new method from it.

```java
public Either<String, Money> convert(Money money, Currency toCurrency) {
    return null;
}

public ConversionResult<String> convertWithConversionResult(Money money, Currency to) {
    return canConvert(money, to)
            ? fromSuccess(convertSafely(money, to))
            : fromFailure(String.format("%s->%s", money.currency(), to));
}
```

:green_circle: We implement the method the same way as the old one by using `left()` and `right()` method from `Either`

```java
public Either<String, Money> convert(Money money, Currency toCurrency) {
    return canConvert(money, toCurrency)
            ? right(convertSafely(money, toCurrency))
            : left(String.format("%s->%s", money.currency(), toCurrency))
}
```

:large_blue_circle: Refactor time!

Let's adapt the existing tests to call our new `convert` method.

```java
class BankTest {
    ...
    @Test
    @DisplayName("10 EUR -> EUR = 10 EUR")
    void shouldConvertInSameCurrency() {
        assertThat(bank.convert(euros(10), EUR))
                .containsOnRight(euros(10));
    }

    @Test
    @DisplayName("Return a failure result in case of missing exchange rate")
    void shouldReturnAFailingResultInCaseOfMissingExchangeRate() {
        assertThat(bank.convert(euros(10), KRW))
                .containsOnLeft("EUR->KRW");
    }

    @Test
    @DisplayName("Conversion with different exchange rates EUR to USD")
    void shouldConvertWithDifferentExchangeRates() {
        assertThat(bank.convert(euros(10), USD))
                .containsOnRight(dollars(12));

        assertThat(bank.addExchangeRate(EUR, USD, 1.3)
                .convert(euros(10), USD))
                .containsOnRight(dollars(13));
    }
}
```

### Portfolio refactoring

Refactor the `Portfolio` to use the new `convert` method as well from the `Bank` class.
- We start by adapting the `convertAllMoneys` method

```java
private List<Either<String, Money>> convertAllMoneys(Bank bank, Currency toCurrency) {
    return moneys.stream()
            .map(money -> bank.convert(money, toCurrency))
            .toList();
}
```

Then, let's use our compiler errors as a refactoring driver:
![Compiler errors as driver](img/monad-compiler-as-driver.png)

After having refactored the `Portfolio` it looks like this:
```java
public Either<String, Money> evaluate(Bank bank, Currency toCurrency) {
    var convertedMoneys = convertAllMoneys(bank, toCurrency);

    return containsFailure(convertedMoneys)
            ? left(toFailure(convertedMoneys))
            : right(sumConvertedMoney(convertedMoneys, toCurrency));
}

private Money sumConvertedMoney(List<Either<String, Money>> convertedMoneys, Currency toCurrency) {
    return new Money(convertedMoneys.stream()
            .filter(Either::isRight)
            .map(e -> e.getOrElse(new Money(0, toCurrency)))
            .mapToDouble(Money::amount)
            .sum(), toCurrency);
}

private String toFailure(List<Either<String, Money>> convertedMoneys) {
    return convertedMoneys.stream()
            .filter(Either::isLeft)
            .map(Either::getLeft)
            .map(e -> String.format("[%s]", e))
            .collect(Collectors.joining(",", "Missing exchange rate(s): ", ""));
}

private boolean containsFailure(List<Either<String, Money>> convertedMoneys) {
    return convertedMoneys
            .stream()
            .anyMatch(Either::isLeft);
}

private List<Either<String, Money>> convertAllMoneys(Bank bank, Currency toCurrency) {
    return moneys.stream()
            .map(money -> bank.convert(money, toCurrency))
            .toList();
}
```

Let's clean our code: remove duplication and dead code
- We can safely delete the `convertWithConversionResult` method from `Bank`
- We can now delete the `ConversionResult` class

## Use vavr collections
:large_blue_circle: Let's use the advantages of `vavr` to simplify our code

It comes with a large variety of immutable collections and functions that we can use to simplify our code. You can check them [here](https://docs.vavr.io/#_performance_characteristics).

### Bank
:red_circle: We start by using `io.vavr.collection.Map`, we can remove the call to `Collections.unmodifiableMap`

```java
import io.vavr.collection.HashMap;
import io.vavr.collection.Map;
import io.vavr.control.Either;

public final class Bank {
    private final Map<String, Double> exchangeRates;

    private Bank(Map<String, Double> exchangeRates) {
        this.exchangeRates = exchangeRates;
    }
    ...
```

:green_circle: Then we adapt other methods and make our tests green again.

```java
public final class Bank {
    private final Map<String, Double> exchangeRates;

    private Bank(Map<String, Double> exchangeRates) {
        this.exchangeRates = exchangeRates;
    }

    public static Bank withExchangeRate(Currency from, Currency to, double rate) {
        var bank = new Bank(HashMap.empty());
        return bank.addExchangeRate(from, to, rate);
    }

    public Bank addExchangeRate(Currency from, Currency to, double rate) {
        // put method returns a new instance of the Map
        return new Bank(exchangeRates.put(keyFor(from, to), rate));
    }
    
    ...
    
    // We use the getOrElse method allowing us to get the result safely and provide a default value if not found
    private Money convertSafely(Money money, Currency to) {
        return money.currency() == to
                ? money
                : new Money(money.amount() * exchangeRates.getOrElse(keyFor(money.currency(), to), 0d), to);
    }
}
```

### Portfolio
:red_circle: We start by using `io.vavr.collection.Seq`, we can remove the call to `Collections.unmodifiableMap`

```java
public final class Portfolio {
    private final Seq<Money> moneys;

    public Portfolio() {
        this.moneys = Vector.empty();
    }

    private Portfolio(Seq<Money> moneys) {
        this.moneys = moneys;
    }

    public Portfolio add(Money money) {
        return new Portfolio(moneys.append(money));
    }
    ...
}
```

:green_circle: Then we adapt other methods and make our tests green again

> Observe that we don't need to use stream api anymore. Functions like `map` are accessible directly from the data structure itself.

```java
public Either<String, Money> evaluate(Bank bank, Currency toCurrency) {
    var convertedMoneys = convertAllMoneys(bank, toCurrency);

    return containsFailure(convertedMoneys)
            ? left(toFailure(convertedMoneys))
            : right(sumConvertedMoney(convertedMoneys, toCurrency));
}

private Seq<Either<String, Money>> convertAllMoneys(Bank bank, Currency toCurrency) {
    return moneys.map(money -> bank.convert(money, toCurrency));
}

private boolean containsFailure(Seq<Either<String, Money>> convertedMoneys) {
    return convertedMoneys.exists(Either::isLeft);
}

// Use mkstring method instead of Collector
private String toFailure(Seq<Either<String, Money>> convertedMoneys) {
    return convertedMoneys
            .filter(Either::isLeft)
            .map(e -> String.format("[%s]", e.getLeft()))
            .mkString("Missing exchange rate(s): ", ",", "");
}

// Use the reduce method on double amounts
private Money sumConvertedMoney(Seq<Either<String, Money>> convertedMoneys, Currency toCurrency) {
    return new Money(convertedMoneys
            .filter(Either::isRight)
            .map(e -> e.getOrElse(new Money(0, toCurrency)))
            .map(Money::amount)
            .reduce(Double::sum), toCurrency);
}
```

We take advantage of this refactoring to reorganise the methods so that they can be read in their order of usage.

### DomainUtility
We use `streams` in this class as well so let's simplify it by using `vavr` as well

```java
public static Portfolio portfolioWith(Money... moneys) {
    return Vector.of(moneys)
            .foldLeft(new Portfolio(), Portfolio::add);
}
```

## Reflect
- What do you think about those concepts and this library?
- What could you do with it?

![Monads by example](../../docs/img/monad.png)
