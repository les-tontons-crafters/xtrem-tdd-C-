- Parler Outside-In TDD + ATDD 
- Parler Clean Architecture
  - Screaming Architecture 
- Parler Parse don't validate
  - Montrer sur Clean Archi les parsers
- Parler CQRS

## Add an Acceptance Test
- Add cucumber
```xml
<properties>
    ...
    <cucumber.version>7.8.1</cucumber.version>
</properties>

<dependency>
    <groupId>io.cucumber</groupId>
    <artifactId>cucumber-java</artifactId>
    <version>${cucumber.version}</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>io.cucumber</groupId>
    <artifactId>cucumber-junit</artifactId>
    <version>${cucumber.version}</version>
    <scope>test</scope>
</dependency>
```
- Install Cucumber plugin available [here](https://plugins.jetbrains.com/plugin/7212-cucumber-for-java)
- Automate run through junit

```java
@RunWith(Cucumber.class)
public class CucumberRunnerTest {

}
```

- Suppress warning by adding cucumber.properties

```properties
cucumber.publish.quiet=true
```

- Fix `SL4J` issue:

```xml
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
    <version>${slf4j.version}</version>
</dependency>
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-simple</artifactId>
    <version>${slf4j.version}</version>
</dependency>
```


- Create a first `scenario`

```gherkin
Feature: Portfolio evaluation
  Customers can evaluate their Portfolio in the 3 currencies supported by our system.

  Background:
    Given our Bank system with EUR as Pivot Currency
    And exchange rate of 1.2 defined for USD
    And exchange rate of 1344 defined for KRW

  Scenario: Evaluate in EUR
    Given an existing portfolio
    And our customer adds 5678.89 USD on their portfolio
    And our customer adds 5674567.245 KRW on their portfolio
    And our customer adds 9432 USD on their portfolio
    And our customer adds 4989.67 EUR on their portfolio
    When they evaluate their portfolio in EUR the amount should be closed to 21804.227
```

:red_circle: generate steps for `Background` and the `Scenario`

What do we need in this test if we follow Clean Architecture principles?

![Acceptance test skeleton](img/acceptance-tests-skeleton.png)

- Create what we need with `generate code from usage`
```java
public class PortfolioEvaluationStepDefinitions {

    private final SetupBankUseCase setupBankUseCase = new SetupBankUseCase();
    private final AddExchangeRateUseCase addExchangeRateUseCase = new AddExchangeRateUseCase();
    private final CreateCustomerUseCase createCustomerUseCase = new CreateCustomerUseCase();
    private final AddMoneyInPortfolioUseCase addInPortfolioUseCase = new AddMoneyInPortfolioUseCase();
    private final EvaluatePortfolioUseCase evaluatePortfolioUseCase = new EvaluatePortfolioUseCase();
    private final UUID customerId = UUID.randomUUID();

    @Given("our Bank system with {word} as Pivot Currency")
    public void bankWithPivot(String currency) {
        setupBankUseCase.invoke(new SetupBank(parseCurrency(currency)));
    }

    @And("exchange rate of {double} defined for {word}")
    public void addExchangeRate(double rate, String currency) {
        addExchangeRateUseCase.invoke(new AddExchangeRate(rate, parseCurrency(currency)));
    }

    @Given("an existing customer")
    public void anExistingCustomer() {
        createCustomerUseCase.invoke(new CreateCustomer(customerId));
    }

    @And("they add {double} {word} on their portfolio")
    public void addInPortfolio(double amount, String currency) {
        addInPortfolioUseCase.invoke(new AddInPortfolio(customerId, amount, parseCurrency(currency)));
    }

    @When("they evaluate their portfolio in {word} the amount should be closed to {double}")
    public void evaluate(String currency, double expectedAmount) {
        var parsedCurrency = parseCurrency(currency);
        var evaluationResult = evaluatePortfolioUseCase.invoke(new EvaluatePortfolio(customerId, parsedCurrency));

        assertThat(evaluationResult)
                .hasRightValueSatisfying(received -> assertClosedTo(received, new Money(expectedAmount, parsedCurrency)));
    }

    private void assertClosedTo(EvaluationResult evaluationResult, Money expected) {
        Assertions.assertThat(evaluationResult.evaluatedAt()).isCloseTo(LocalDateTime.now(), byLessThan(1, ChronoUnit.SECONDS));
        Assertions.assertThat(evaluationResult.currency()).isEqualTo(expected.currency());
        Assertions.assertThat(evaluationResult.amount()).isCloseTo(expected.amount(), offset(0.001d));
    }

    private Currency parseCurrency(String currency) {
        return of(Currency.values())
                .find(c -> c.toString().equals(currency))
                .get();
    }
}
```

We should avoid manipulating `non deterministic data` in our tests: `LocalDateTime.now()`. We will have to do something about it...

- Take a look at code organization

![Use case folders](img/acceptance-tests-usecases.png)

After having generated the code, our `acceptance test` fails because nothing is implement.

Congrats, you have a first failing `acceptance test` that we will use as an implementation driver.

![Acceptance test failure](img/acceptance-tests-failure.png)

## TDD Loops
- Go at the Unit Test Level and work on a first Use Case.

> What are the responsibilities of Use Cases?

- Fetch a repository to identify if the customer exists in the system
  - If so, delegate the business logic to the domain entity then store the new state
  - If no, return an error

### TDD on SetupBank
- Use Case tests are coupled to the system API, not the system implementation
- Use Case tests are readable as requirement specs, rather than implementation specs
- High coverage at low test maintenance costs, thus increasing ROI
- High test robustness, we can refactor the system safely without breaking tests

